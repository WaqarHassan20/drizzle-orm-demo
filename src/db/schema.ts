import {
  pgEnum,
  pgTable,
  uuid,
  varchar,
  integer,
  uniqueIndex,
  boolean,
  real,
  timestamp,
  primaryKey,
} from "drizzle-orm/pg-core";

/*
  Schema overview and conventions

  - Purpose: This file declares the Postgres schema for a small demo app using Drizzle's
    `pg-core` helpers. It includes users, user preferences (1:1), posts (1:N), categories
    and a join table for posts<->categories (N:M).

  - Naming: tables use snake_case (e.g. `user_preferences`) and columns use camelCase where
    convenient in code but maintain the underlying db names as provided to the column helpers.

  - Enums: `pgEnum` is used for database-backed enums (stable values stored in Postgres).

  Indexing guidance (practical notes):
  - Indexes speed up SELECTs that filter, join, or sort. Prefer indexes on high-cardinality
    columns used in WHERE / JOIN / ORDER BY.
  - Unique constraints (e.g. `.unique()` on a column) create a unique index automatically.
    Declaring both a column-level `.unique()` and an explicit `uniqueIndex` on the same column
    is redundant and can be removed to avoid duplicate indexes.
  - Avoid indexing very low-cardinality columns (booleans, small enums) unless part of a
    composite or partial index targeting a specific query pattern.
  - Use EXPLAIN / ANALYZE to verify an index is being used; add or remove indexes based on
    real query plans rather than just intuition.

  Migration notes:
  - If you change index definitions or enums, update your SQL migrations. Enums require careful
    migration steps in Postgres (adding values vs. replacing the type).
*/

/*
  UserRole enum

  - Represents the allowed roles a user can have in the system.
  - Stored as a Postgres enum type named `userRole` so values are constrained at the DB level.
  - Typical values: ADMIN (full privileges), USER (regular authenticated user), GUEST (limited access).
  - When adding/removing enum values, update migrations carefully (Postgres enum alterations are
    non-destructive but require explicit ALTER TYPE steps).
*/
export const UserRole = pgEnum("userRole", ["ADMIN", "USER", "GUEST"]);

/*
  Users table

  - Purpose: stores user accounts and basic profile information.
  - Columns:
    - id: UUID primary key generated by the database (`defaultRandom()`).
    - name: user-visible name (varchar(255)), required.
    - email: unique contact/login email. Declared with `.unique()` to enforce uniqueness at the DB level.
    - age: integer (required). Depending on your domain you may want this nullable or validated at the app layer.
    - role: enum (`userRole`) with a default of `GUEST`.

  - Indexing notes: the `.unique()` on `email` creates a unique index automatically. The explicit
    `uniqueIndex("emailIndex")` below would be redundant if left in place; keep only one to avoid
    duplicate indexes. The `uniqueNameAndAge` composite index shows how to create a multi-column
    unique constraint/index when your application requires uniqueness across columns.
*/
export const UserTable = pgTable(
  "users",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    name: varchar("name", { length: 255 }).notNull(),
    // if you remove the uniqueIndex below, this unique constraint will still create an index, so use one or the other
    email: varchar("email", { length: 255 }).notNull().unique(),
    age: integer("age").notNull(),
    role: UserRole("userRole").default("GUEST").notNull(),
  },

  /*
    Index definitions (newer syntax)

    - Use the `uniqueIndex` helper to declare indices outside the column definition when you
      need named, composite, or conditional indexes. If a column already uses `.unique()`, do
      not also create an identical `uniqueIndex` on that column.
  */
  (table) => [
    // don't use both this and the .unique() on email column above; they do the same thing, else will cause the redundancy
    uniqueIndex("emailIndex").on(table.email),
    uniqueIndex("uniqueNameAndAge").on(table.name, table.age),
  ]
);

// This is one to one relationship example
/*
  User preferences (one-to-one)

  - Purpose: stores per-user settings/preferences that are small and frequently updated.
  - Columns:
    - id: UUID primary key.
    - emailUpdates: boolean flag for whether the user wants email notifications (default: false).
    - userId: FK referencing `users.id` to associate the prefs with a user.

  - Relationship: this is intended to be a one-to-one mapping between a user and their preferences.
    You can enforce the 1:1 constraint at the DB level with a unique index on `userId` if desired.
*/
export const userPreferencesTable = pgTable("user_preferences", {
  id: uuid("id").primaryKey().defaultRandom(),
  emailUpdates: boolean("emailUpdates").notNull().default(false),
  userId: uuid("userId").references(() => UserTable.id),
});

// This is now the one to many relationship example
/*
  Posts (one-to-many)

  - Purpose: stores posts or other authored content associated with a user (author).
  - Columns:
    - id: UUID primary key.
    - title: short textual title for the post.
    - averageRating: floating point rating (real) with a default of 0.
    - createdAt / updatedAt: timestamps with `defaultNow()`; update `updatedAt` from the application
      when the record changes (or use triggers if you prefer DB-side handling).
    - authorId: FK referencing `users.id`, NOT NULL because every post must have an author.

  - Relationship: one user can have many posts (1:N). Consider an index on `authorId` if you
    frequently query posts by author.
*/
export const userPostsTable = pgTable("posts", {
  id: uuid("id").primaryKey().defaultRandom(),
  title: varchar("title", { length: 255 }).notNull(),
  averageRating: real("averageRating").notNull().default(0),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
  authorId: uuid("authorId")
    .references(() => UserTable.id)
    .notNull(),
});

// This is now many to many relationship example
/*
  Categories

  - Purpose: simple lookup table for categories/tags that can be attached to posts.
  - Columns:
    - id: UUID primary key.
    - name: category name (varchar).
*/
export const CategoryTable = pgTable("categories", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: varchar("name", { length: 255 }).notNull(),
});

/*
  PostCategories (many-to-many join table)

  - Purpose: implements a many-to-many relationship between `posts` and `categories`.
  - Columns:
    - postId: FK to `posts.id`.
    - categoryId: FK to `categories.id`.
  - Primary key: composite primary key on (postId, categoryId) prevents duplicate pairings and
    keeps the table compact.
  - Indexing: the composite PK acts as an index for lookups by post+category. Add individual
    indexes on `postId` or `categoryId` only if query patterns require them (for example, listing
    all posts in a category or all categories for a post).
*/
export const PostCategoryTable = pgTable(
  "post_categories",
  {
    postId: uuid("postId")
      .references(() => userPostsTable.id)
      .notNull(),
    categoryId: uuid("categoryId")
      .references(() => CategoryTable.id)
      .notNull(),
  },
  (table) => [primaryKey({ columns: [table.postId, table.categoryId] })]
);
